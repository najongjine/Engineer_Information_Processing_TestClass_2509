기본 연산자
+ - * / %

논리연산
&& ||

논리곱
&

논리합
|

xor
^

비트연산
<< 
>>

제어연산
if()

operator
++ --


// Online C compiler to run C program online
#include <stdio.h>

int main() {
int a=1;
int b=2;

printf("a+b: %d \n",a+b);
printf("a-b: %d \n",a-b);
printf("a/b:%f \n",a/(float)b);

/*
나머지값 구하기
이거 특징이 a%b 예시로 보면,
결과값은 a 보다 같거나 클수 없다
*/
printf("a/b: %d \n", a%b);

int t1=2;
int t2=3;
int f1=0;
printf("%d \n", t1 && t2);
printf("%d \n", t1 && f1);
printf("%d \n",t1 || f1);

/*
논리곱, 논리합은 2진수로 변환한후 계산이 됩니다
2 -> 1 0
3 -> 1 1    AND
     1 0 
     
     1(2^1) 0(2^0)
     2^0 은 없다. 그래서 0
     2^1 은 있다. 그래서 2
     2 + 0 = 2
       
*/
printf("&: %d \n",t1&t2); // 2

/*
2 -> 1 0
3 -> 1 1    OR
     1 1 
     
     1(2^1) 1(2^0)
     2^0 은 있다. 그래서 1
     2^1 은 있다. 그래서 2
     2 + 1 = 3
       
*/
printf("|: %d \n", t1|t2); // 3

/*
2 -> 1 0
3 -> 1 1    XOR
     0 1 
     
     1(2^1) 1(2^0)
     2^0 은 있다. 그래서 1
     2^1 은 없다. 그래서 0
     1
*/
printf("^: %d \n",t1 ^ t2); //1

/*
비트연산
10101... 요런 값들을 화살표 방향으로 밀어라
<< 1: 왼쪽 화살표 방향으로 1칸 이동
11 -----> 110
그래서 6이 됨
*/
printf("<<: %d \n", t2 << 1); // 6
printf("t2:%d \n",t2);

/*
>> shift 연산은 많이 특이해요.
11 (낭떠러지) 이렇게 있다고 생각 하세요

오른쪽 방향으로 밀면, 비트가 낭떠러지에 떨어져서 죽어요

1    1(얘는 밀려서 떨어져 죽음)
그래서 1만 남음
*/
printf(">>: %d \n", t2 >> 1);


    return 0;
}