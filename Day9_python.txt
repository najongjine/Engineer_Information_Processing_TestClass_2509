파이썬은 interpreter 언어에요
파이썬은 main이 없어요( scope 개념이 거진 없다는 거에요)
파이썬은 변수에 데이터 타입은 존재 하지만, 눈에 보이지는 않아요
파이썬은 ; 필요 없어요

** == 수학에서 하던 제곱. 2**2 = 4
// == 소수점은 갔다 버려라. 1//2 = 0
and == &&
or == ||

1>2 or 2==2 # 1

a=45 # int
a="hello" # 문자열

python string Slicing
b = "Hello,"
print(b[2:5]) # llo
print(b[0:2]) # He
print(b[:2]) # He
print(b[3:]) # lo,

a = "Hell"
b = "o"
c = a + b
print(c) # 문자열은 + 기호로 붙일수 있다

age = 36
print(f"My name is John, I am {age}") # {age} 부분에 36이 쏙 들어가요
txt = "We are the so-called \"Vikings\" from the north." # 문자열 안에 " 같은거 넣고 싶을때 \ 써주면 된다

txt = "I love apples, apple are my favorite fruit"
x = txt.count("apple") # txt 문자열에서 apple 이 몇번 등장했니

txt = "Hello, welcome to my world."
print(txt.find("e")) # 1
print(txt.index("e")) # 1

myTuple = ("John", "Peter", "Vicky")
x = "#".join(myTuple)
print(x) # John#Peter#Vicky

txt = "I like bananas"
# replace 뜻이 바꾸다 라는 뜻. 즉, 이 코드는 bananas 를 apples로 바꿔라
x = txt.replace("bananas", "apples")
print(x) # I like apples

txt = "I like bananas"
# a 라는걸 e로 싹 바꿔라
x = txt.replace("a", "e")
print(x) # I like benenes

txt = "50"
# 3 자리로 맞춰라. 근데 원본 데이터가 2자리면 왼쪽을 0으로 채워라
x = txt.zfill(3)
print(x) # 050

txt = "5000"
# zfill은 원본 데이터 크기가 매개변수보다 더 크다고, 데이터를 짤라먹진 않아요
x = txt.zfill(3)
print(x) # 5000



a= True # boolean
a= 3.4 # float

#   0 1
a= [1,2] # array
a[0] # 1

#             -3         -2        -1
thislist = ["apple", "banana", "cherry"]
# 파이썬은 list 를 뒤에서부터도 접근할수 있어요
print(thislist[-1])

thislist = ["apple", "banana", "cherry", "orange", "kiwi", "melon", "mango"]
print(thislist[2:-2]) # ['cherry', 'orange', 'kiwi']

thislist = ["apple", "banana", "cherry"]
if "apple" in thislist:
  print("Yes, 'apple' is in the fruits list")

thislist = ["apple", "banana", "cherry", "orange", "kiwi"]
thislist[1:3] = ["blackcurrant", "watermelon"]
print(thislist) # ['apple', 'blackcurrant', 'watermelon', 'orange', 'kiwi']

thislist = ["apple", "banana", "cherry"]
# 자바는 list 끝에만 원소추가가 되는데, 파이썬은 아무대나 막 할수 있데요
thislist.insert(1, "watermelon")
print(thislist) # ['apple', 'watermelon', 'banana', 'cherry']

thislist = ["apple", "banana", "cherry"]
# 자료구조 stack pop 생각하면 안됨. 파이썬은 pop() 이건 list에서 맨 마지막꺼 제거
# pop(1) 이러면 index 1 번째거 제거 
# 그리고 pop은 제거하면서 값을 퉤 뱉음. 그래서 변수에 담거나 loop에서 재사용 가능함
data=thislist.pop(1)
print(thislist) # 
thislist = ["apple", "banana", "cherry"]
data=thislist.pop(1)
print(thislist)

thislist = ["apple", "banana", "cherry"]
data=thislist.pop(1)
print(thislist) # ['apple', 'cherry']



a= {1, 2, 3} # set. 중복을 허용하지 않는다, 순서가 없다
a.add(4)
a.remove(1)



a= (1, 2, 3) # tuple. 순서를 가지며 변경할 수 없다.
a[0] = 10   # ❌ TypeError! 튜플은 값을 바꿀 수 없다
t = (1, 2)
print(t * 3)   # 👉 (1, 2, 1, 2, 1, 2)
print(t[0]) # 1
