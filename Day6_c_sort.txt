
#include <stdio.h>

int main() {
    char a[] = {'a','b','\0'};  // 정렬할 배열
    //         0  1  2  3   4
    int a[] = {5, 1, 4, 2, 8};  // 정렬할 배열
    int n = sizeof(a) / sizeof(a[0]); // 5

    // i  0 ~ 3     i=1
    for (int i = 0; i < n - 1; i++){
        // j=1 조건체크 1 < 3
        for (int j = 0; j < n - 1 - i; j++){
            // 4 > 2 조건이 만족 값 바꿈 a=[1,2,4,5,8]
            if (a[j] > a[j + 1]) {
                // 값 바꾸기   
                int t = a[j]; 
                a[j] = a[j + 1]; 
                a[j + 1] = t;
            }
        }
    }
    /*
    i=0,j=0 결과:  a=[1,5,4,2,8]
    i=0,j=1 결과:  a=[1,4,5,2,8]
    i=0,j=2 결과:  a=[1,4,2,5,8]
    i=0,j=3 결과:  a=[1,4,2,5,8]
    i=1,j=0 결과:  a=[1,4,2,5,8]
    i=1,j=1 결과:  a=[1,2,4,5,8]
    */
    for (int i = 0; i < n; i++) printf("%d ", a[i]);
    return 0;
}



#include <stdio.h>

int main() {
    int a[] = {5, 1, 4, 2, 8};
    int n = sizeof(a) / sizeof(a[0]); //5

    // i 1 ~ 4   i=1
    for (int i = 1; i < n; i++) {
        // 1
        int key = a[i]; 
        // j 는 i 보다 왼쪽   j=0
        j = i - 1;
        // j 동적
        while (j >= 0 && a[j] > key)  a[0] = 5   > 1
            // j 의 오른쪽 값을 j의 왼쪽값으로
            a[j + 1] = a[j--];    //   a[1] = a[-1]
        // j의 오른쪽 값을 key로 복원   
        a[j + 1] = key;  
    }

    for (int i = 0; i < n; i++) printf("%d ", a[i]);
    return 0;
}
